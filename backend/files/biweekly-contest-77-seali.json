{
    "rank": 426,
    "username": "seali",
    "score": 18,
    "finish_time": "01:39:45",
    "Q1": {
        "solve_time": "00:02:51",
        "fail_count": 0,
        "lang": "cpp",
        "code": "class Solution {\nprivate:\n    unordered_set<string> set;\npublic:\n    int countPrefixes(vector<string>& words, string s) {\n        \n        string tmp;\n        \n        for(auto& c : s) {\n            tmp += c;\n            set.insert(tmp);    \n        }\n        int output = 0;\n        for(auto& word : words)\n            if (set.find(word) != set.end())\n                output ++;\n        \n        return output;\n    }\n};"
    },
    "Q2": {
        "solve_time": "00:15:29",
        "fail_count": 1,
        "lang": "cpp",
        "code": "class Solution {\nprivate:\n    int abs(int x) {\n        return x >= 0 ? x : -x; \n    }\npublic:\n    int minimumAverageDifference(vector<int>& nums) {\n        \n        vector<long long > front(nums.size()); \n        vector<long long > back(nums.size(), 0);\n        \n        long long  sum = 0;\n        long long  count = 0;\n        \n        for(int i = 0; i < nums.size(); i++) {\n            count ++;\n            sum += nums[i];\n            front[i] = sum/count;\n        }\n\n        \n        sum = 0; count = 0;\n        \n        for(int i = nums.size()-2; i>=0; i--) {\n            count ++;\n            sum += nums[i+1];\n            back[i] = sum/count;\n        }\n        \n\n        \n        int mini = INT_MAX;\n        int output = -1;\n        \n        for(int i = 0 ; i < nums.size(); i++) {\n            if (abs(front[i]-back[i]) < mini) {\n                mini = abs(front[i]-back[i]);\n                output = i;\n            }\n        }\n        \n        return output;\n        \n    }\n};"
    },
    "Q3": {
        "solve_time": "00:28:51",
        "fail_count": 0,
        "lang": "cpp",
        "code": "class Solution {\npublic:\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\n        \n        vector<vector<int>> panel(m, vector<int>(n, 0));\n        \n        for(auto& guard : guards)\n            panel[guard[0]][guard[1]] = 1;\n        \n        for(auto& wall : walls)\n            panel[wall[0]][wall[1]] = 2;\n        \n        for(auto& guard : guards) {\n            int x = guard[0];\n            int y = guard[1];\n            \n            int begin = x-1;\n            \n            while(begin >= 0) {\n                if (panel[begin][y] == 1 || panel[begin][y] == 2)\n                    break;\n                panel[begin][y] = -1;\n                begin --;\n            }\n            \n            begin = x+1;\n            \n            while(begin < m) {\n                if (panel[begin][y] == 1 || panel[begin][y] == 2)\n                    break;\n                panel[begin][y] = -1;\n                begin ++;\n            }\n            \n            begin = y - 1;\n            \n            while(begin >= 0) {\n                if (panel[x][begin] == 1 || panel[x][begin] ==2)\n                    break;\n                panel[x][begin] = -1;\n                begin --;\n            }\n            \n            begin = y+1;\n            \n            while(begin < n) {\n                if (panel[x][begin] == 1 || panel[x][begin] ==2)\n                    break;\n                panel[x][begin] = -1;\n                begin ++;\n            }\n\n        }\n        int output = 0;\n        for(int i = 0 ; i < m; i++) {\n            for(int j = 0 ; j < n; j++) {\n                if (panel[i][j] == 0)\n                    output ++;\n            }\n        }\n        \n        return output;\n        \n    }\n};"
    },
    "Q4": {
        "solve_time": "01:29:45",
        "fail_count": 1,
        "lang": "cpp",
        "code": "class Solution {\npublic:\n    int maximumMinutes(vector<vector<int>>& grid) {\n        \n        vector<vector<int>> human(grid.size(), vector<int>(grid[0].size(), -1));\n        \n        \n        queue<pair<int, pair<int, int>>> q;\n        \n        q.push({0, {0, 0}});\n        \n        while(q.size()) {\n            auto pair_ = q.front(); q.pop();\n            \n            int walk = pair_.first; int x = pair_.second.first; int y = pair_.second.second;\n            \n            if (grid[x][y] == 2)\n                continue;\n            if (human[x][y] != -1)\n                continue;\n            \n            human[x][y] = walk;\n            \n            if (x > 0)\n                q.push({walk+1, {x-1, y}});\n            if (x < grid.size()-1)\n                q.push({walk+1, {x+1, y}});\n            if (y > 0)\n                q.push({walk+1, {x, y-1}});\n            if (y < grid[0].size()-1)\n                q.push({walk+1, {x, y+1}});\n        }\n        \n        \n        int m = grid.size(); int n = grid[0].size();\n        \n        vector<vector<int>> fire(grid.size(), vector<int>(grid[0].size(), INT_MAX));\n        \n        for(int i =0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if (grid[i][j] == 1)\n                    q.push({0, {i, j}});\n            }\n        }\n        \n        while(q.size()) {\n            auto pair_ = q.front(); q.pop();\n            \n            int walk = pair_.first; int x = pair_.second.first; int y = pair_.second.second;\n            \n            if (grid[x][y] == 2)\n                continue;\n            if (fire[x][y] != INT_MAX)\n                continue;\n            \n            fire[x][y] = walk;\n            \n            if (x > 0)\n                q.push({walk+1, {x-1, y}});\n            if (x < grid.size()-1)\n                q.push({walk+1, {x+1, y}});\n            if (y > 0)\n                q.push({walk+1, {x, y-1}});\n            if (y < grid[0].size()-1)\n                q.push({walk+1, {x, y+1}});\n        }\n\n\n        \n        priority_queue<pair<int, pair<int, int>>> pq;\n        \n        pq.push({fire[0][0] - human[0][0] - 1,{0, 0}});\n        \n        int output = INT_MAX;\n        \n        vector<vector<bool>> visit(grid.size(), vector<bool>(grid[0].size(), false));\n\n        if (fire[grid.size()-1][grid[0].size()-1] < INT_MAX)\n        fire[grid.size()-1][grid[0].size()-1] += 1;\n        \n        while(pq.size())  {\n            \n            auto pair_ = pq.top(); pq.pop();\n            int value = pair_.first;\n            int x = pair_.second.first;\n            int y = pair_.second.second;\n            \n            if (value < 0)\n                break;\n            \n            if (visit[x][y])\n                continue;\n            visit[x][y] = true;\n            \n            if (grid[x][y] == 2)\n                continue;\n            \n            if (x == grid.size()-1 && y == grid[0].size()-1) {\n                if (value > 1e9)\n                    return 1e9;\n                return value;\n            }\n            \n            if (x > 0 && grid[x-1][y] != 2)\n                pq.push({min(value, fire[x-1][y] - human[x-1][y] - 1), {x-1, y}});\n            if (x < grid.size()-1 && grid[x+1][y] != 2)\n                pq.push({min(value, fire[x+1][y] - human[x+1][y] - 1), {x+1, y}});\n            if (y > 0 && grid[x][y-1] != 2)\n                pq.push({min(value, fire[x][y-1] - human[x][y-1] - 1), {x, y-1}});\n            if (y < grid[0].size()-1 && grid[x][y+1] != 2)\n                pq.push({min(value, fire[x][y+1] - human[x][y+1] - 1), {x, y+1}});\n            \n\n        }\n        return -1;\n    }\n};"
    }
}
