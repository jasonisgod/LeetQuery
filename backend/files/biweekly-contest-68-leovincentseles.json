{
    "rank": 554,
    "username": "leovincentseles",
    "score": 12,
    "finish_time": "01:04:37",
    "Q1": {
        "solve_time": "00:03:08",
        "fail_count": 0,
        "lang": "cpp",
        "code": "class Solution {\nprivate:\n    int wordsCount(string &sentence) {\n        int head = 0, tail;\n        int count = 0;\n        while ((tail = sentence.find(\" \", head)) != string::npos) {\n            ++count;\n            head = tail + 1;\n        }\n        \n        ++count;\n        return count;\n    }\npublic:\n    int mostWordsFound(vector<string>& sentences) {\n        int maxVal = 0;\n        \n        for (string &sentence: sentences)\n            maxVal = max(maxVal, wordsCount(sentence));\n        \n        return maxVal;\n    }\n};"
    },
    "Q2": {
        "solve_time": "00:59:37",
        "fail_count": 1,
        "lang": "cpp",
        "code": "/*\nClarification:\n    Given:\n        vector<string> recipes\n        vector<vector<string>> ingredients\n        vector<string> supplies        \n    Return:\n         all the recipes that you can create.\n         \n        \nA -> B\nA, B -> C\n\n[\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n\n\"bread\" <- yeast, flour\n         \nSolution: Topological sort\n\n        \n*/\n\nclass Solution {\npublic:\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\n        vector<string> result;\n        unordered_map<string, int> indegree;\n        unordered_set<string> recipeSet;\n        \n        unordered_map<string, vector<string>> graph;\n        \n        for (int i=0; i<recipes.size(); ++i) {\n            string recipe = recipes[i];\n            vector<string> &ingredient = ingredients[i];\n            recipeSet.insert(recipe);\n                        \n            for (string &ing: ingredient) {\n                graph[ing].push_back(recipe);\n                indegree[recipe]++;    \n            }\n        }\n        \n        queue<string> q;\n        for (string &supply: supplies) {\n            q.push(supply);\n        }\n        \n        while (!q.empty()) {\n            string food = q.front();\n            //printf(\"Food: %s\\n\", food.c_str());\n            \n            if (recipeSet.count(food) != 0)\n                result.push_back(food);\n            q.pop();\n            //printf(\"54\\n\");\n            \n            if (graph.count(food) == 0)\n                continue;\n            //printf(\"59\\n\");\n            vector<string> &neighbors = graph[food];\n            //printf(\"57\\n\");\n            for (string &neighbor: neighbors) {\n                //printf(\"5\\n\");\n                --indegree[neighbor];\n                //printf(\"612\\n\");\n                if (indegree[neighbor] == 0) {\n                    q.push(neighbor);\n                } \n            } \n            \n            //printf(\"61\\n\");\n        }\n        \n        return result;\n    }\n};"
    },
    "Q3": {
        "solve_time": "00:52:06",
        "fail_count": 0,
        "lang": "cpp",
        "code": "/*\nClarification:\n    Given:\n        string s\n        string locked\n    Return:\n        true false\n        if can match all the parentheses\n        \ns = \"))()))\", locked = \"010100\"\n\ns = \"()))\"\nl = \"1101\"\n\nSolution: Brute force\n\nSolution: Dynamic Programming\n    1. dp[][]\n*/\n\nclass Solution {\npublic:\n    bool canBeValid(string s, string locked) {\n        if (s.size() & 1)\n            return false;\n        \n        int nLeft = 0, nRight = 0;\n        int nOthers = 0;\n        \n        for (int i=0; i<s.size(); ++i) {\n            char ch = s[i];\n            char isLocked = locked[i];\n            \n            if (isLocked == '1') {\n                if (ch == '(')\n                    ++nLeft;\n                else\n                    ++nRight;\n            }                        \n        }\n        // printf(\"%d, %d\\n\", nLeft, nRight);\n        nOthers = s.size() - nLeft - nRight;\n        \n        if (nLeft > s.size()/2 || nRight > s.size()/2)\n            return false;\n        \n        int nOtherLeft = s.size() / 2 - nLeft;\n        int nOtherRight = s.size() / 2 - nRight;\n        \n        // printf(\"%d, %d, %d, %d\\n\", nLeft, nRight, nOtherLeft, nOtherRight);\n        \n        stack<char> charStack;\n        for (int i=0; i<s.size(); ++i) {\n            // printf(\"%d\\n\", i);\n            char ch = s[i];\n            char isLocked = locked[i];\n            \n            if (isLocked == '0') {\n                if (nOtherLeft > 0) {\n                    --nOtherLeft;\n                    ch = '(';\n                } else\n                    ch = ')';                    \n            }\n            \n            if (ch == '(')\n                charStack.push(ch);\n            else if (charStack.size() == 0)\n                return false;\n            else\n                charStack.pop();\n        }\n        \n        return charStack.empty();\n    }\n};"
    },
    "Q4": {}
}
