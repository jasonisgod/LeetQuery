{
    "rank": 248,
    "username": "leovincentseles",
    "score": 19,
    "finish_time": "01:00:16",
    "Q1": {
        "solve_time": "00:07:23",
        "fail_count": 0,
        "lang": "cpp",
        "code": "/*\nClarification:\n    Given:\n        vector<int> nums\n        int k\n    Return:\n        any such subsequence\nSolution:\n    priority_queue<pair<int val, int idx>>;\n    vector<int> idxArr;\n    vector<int> result;    \n\n*/\n\nclass Solution {\npublic:\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\n        if (k > nums.size())\n            return vector<int>{};\n        \n        priority_queue<pair<int, int>> maxHeap;\n        for (int i=0; i<nums.size(); ++i) {\n            maxHeap.push(make_pair(nums[i], i));\n        }\n        \n        vector<int> idxArr;\n        for (int i=0; i<k; ++i) {\n            pair<int, int> maxPair = maxHeap.top();\n            maxHeap.pop();\n            int maxIndex = maxPair.second;\n            idxArr.push_back(maxIndex);\n        }\n        sort(idxArr.begin(), idxArr.end());\n        \n        vector<int> result;\n        for (int i=0; i<k; ++i) {\n            result.push_back(nums[idxArr[i]]);\n        }\n        \n        return result;\n    }\n};"
    },
    "Q2": {
        "solve_time": "00:19:03",
        "fail_count": 0,
        "lang": "cpp",
        "code": "/*\nClarification:\n    Given:\n        vector<int> security\n        int time\n    Return:\n        a list of all days (0-indexed)\n        \nSolution: Dynamic Programming\n1. \n    nonInc[i]: ends at i how many days are non increasing\n    nonDec[i]: starts from i how many days are non decreasing\n2.  nonInc[i]:\n        if (nums[i] <= nums[i - 1]) nonInc[i] = nonInc[i - 1] + 1\n        else nonInc[i] = 1\n    nonDec[i]:\n        if (nums[i] <= nums[i + 1]) nonDec[i] = nonDec[i + 1] + 1\n        else nonDec[i] = 1\n3.\n    traverse each element such that nonInc[i] >= time + 1 && nonDec[i] >= time + 1\n    \nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n*/\n\nclass Solution {\npublic:\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\n        vector<int> nonInc(security.size(), 1), nonDec(security.size(), 1);\n                \n        for (int i=1; i<security.size(); ++i) {\n            if (security[i] <= security[i - 1])\n                nonInc[i] = nonInc[i - 1] + 1;            \n        }\n        \n        for (int i=security.size()-2; i>=0; --i) {\n            if (security[i] <= security[i + 1]) {\n                nonDec[i] = nonDec[i + 1] + 1;                \n            }\n        }\n        \n        vector<int> result;\n        for (int i=0; i<security.size(); ++i) {\n            if (nonInc[i] >= time + 1 && nonDec[i] >= time + 1)\n                result.push_back(i);\n        }\n        \n        return result;\n    }\n};"
    },
    "Q3": {
        "solve_time": "00:37:03",
        "fail_count": 1,
        "lang": "cpp",
        "code": "/*\nClarification:\n    Given:\n        vector<vector<int>> bombs:\n            bombs[i] = [xi, yi, ri]\n    Return:\n         the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb\n         \nSolution: DFS\n1. build unordered_map<int, vector<int>> graph;\n    foreach pair bombs:\n        bombs[i] -> bombs[j] if bombs[j] is in the range\n        bombs[j] -> bombs[i] if bombs[i] is in the range\n2. Let every node as the source, and do the dfs to calculate the number of nodes can be reached.\n3. unordered_set<int> visited;\n4. add source node\n5. traverse all the edges:\n    if the dest node is unvisited:\n        add to visited\n        dfs(destnode)\n\n*/\n\nclass Solution {\nprivate:\n    unordered_set<int> visited;\n    void dfs(unordered_map<int, vector<int>> &graph, int src) {\n        if (visited.count(src) != 0)\n            return;\n        \n        visited.insert(src);\n        for (int neighbor: graph[src]) {\n            dfs(graph, neighbor);\n        }\n    }\npublic:\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        unordered_map<int, vector<int>> graph;\n        for (int i=0; i<bombs.size()-1; ++i) {\n            for (int j=i+1; j<bombs.size(); ++j) {\n                double xDiff = bombs[i][0] - bombs[j][0];\n                double yDiff = bombs[i][1] - bombs[j][1];\n                double distance = sqrt(xDiff*xDiff + yDiff*yDiff);\n                if (bombs[i][2] >= distance)\n                    graph[i].push_back(j);\n                if (bombs[j][2] >= distance)\n                    graph[j].push_back(i);\n            }\n        }\n        \n        int maxVal = 1;\n        for (int i=0; i<bombs.size(); ++i) {\n            visited.clear();\n            dfs(graph, i);\n            maxVal = max(maxVal, (int)visited.size());\n        }\n        \n        return maxVal;\n    }\n};"
    },
    "Q4": {
        "solve_time": "00:55:16",
        "fail_count": 0,
        "lang": "cpp",
        "code": "/*\n\n\n*/\n\nclass Cmp {\npublic:\n    bool operator()(const pair<string, int> &lhs, const pair<string, int> &rhs) {\n        if (lhs.second != rhs.second)\n            return lhs.second < rhs.second;\n        return lhs.first > rhs.first;\n    }\n};\n\nclass Cmp2 {\npublic:\n    bool operator()(const pair<string, int> &lhs, const pair<string, int> &rhs) {\n        if (lhs.second != rhs.second)\n            return lhs.second > rhs.second;\n        return lhs.first < rhs.first;\n    }\n};\n\nclass SORTracker {\nprivate:\n    priority_queue<pair<string, int>, vector<pair<string, int>>, Cmp> bestLoc;\n    priority_queue<pair<string, int>, vector<pair<string, int>>, Cmp2> storeLoc;\npublic:\n    SORTracker() {\n        \n    }\n    \n    void add(string name, int score) {\n        if (storeLoc.empty()) {\n            bestLoc.push(make_pair(name, score));\n            return;\n        }\n        \n        pair<string, int> worst = storeLoc.top();\n        if (score > worst.second || (score == worst.second && name < worst.first)) {\n            bestLoc.push(worst);\n            storeLoc.pop();\n            storeLoc.push(make_pair(name, score));\n        }\n        else {\n            bestLoc.push(make_pair(name, score));\n        }   \n    }\n    \n    string get() {\n        pair<string, int> best = bestLoc.top();\n        bestLoc.pop();\n        storeLoc.push(best);\n        \n        return best.first;\n    }\n};\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * SORTracker* obj = new SORTracker();\n * obj->add(name,score);\n * string param_2 = obj->get();\n */"
    }
}
